# Internet
---
## How does the internet work?
https://developer.mozilla.org/ko/docs/Learn/Common_questions/How_does_the_Internet_work#%EC%9A%94%EC%95%BD

인터넷은 웹의 핵심적인 기술이다. 컴퓨터가 통신을 하기 위해서는 물리적으로 연결하여 네트워크를 구성한다. 각각의 컴퓨터를 하나씩 연결할 수 없으므로 각 컴퓨터를 라우터에 연결한다. 하지만 국가와 국가 사이처럼 아주 먼 곳을 모두 연결하기는 어렵기에 이미 설치된 전화기 기반의 시설을 이용해야 하며, 네트워크와 전화 시설을 연결하기 위해서는 모뎀이 필요하다. 그렇게 네트워크가 전화 시설에 연결된다. 자신의 컴퓨터가 이러한 네트워크에 도달하기 위해서는 몇몇 특수한 라우터를 관리하는 인터넷 서비스 제공 업체(ISP)를 통해 연결되어야 한다. 이렇게 전체 네트워크가 구성된다.

서로의 컴퓨터에 메시지를 보내기 위해서는 각 컴퓨터의 고유 주소가 필요하다. 이를 IP라고 하며, 점으로 구분된 4개의 숫자(ex. 192.168.2.10)로 구성된다. 하지만 숫자를 기억하기 어렵기 때문에, 좀 더 기억하기 쉬운 도메인 주소(ex. 'google.com')를 이용해 인터넷을 사용한다.

즉 웹 브라우저를 이용해 인터넷을 탐색하기 위해서는 도메인 주소를 이용하여 웹 사이트에 접속한다. 주인의할 것은 웹과 인터넷은 같지 않다는 것이다. 인터넷은 수삽억 대의 컴퓨터를 연결하기 위한 인프라이고, 웹은 그 인프라 위에 구축된 서비스이다.

---
## What is HTTP?
https://developer.mozilla.org/ko/docs/Web/HTTP/Overview

HTTP란 HTML 문서와 같은 리소스를 가져올 수 있도록해주는 프로토콜이다. HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이며, 클라이언트-서버 프로토콜이라고도 한다. 

클라이언트의 사용자 에이전트는 사용자를 대신해 동작하는 모든 도구이다. 주로 브라우저에 의해 이 역할을 수행하며, 브라우저는 항상 요청을 보내는 개체로 결코 서버가 될 수는 없다. 브라우저는 HTML 문서를 가져오기 위한 요청을 전송한 뒤 파일을 구문 분석하여 실행해야 할 스크립트, 페이지 내 포함된 하위 리소스를 잘 표시하기 위한 CSS 정보를 가져온다. 그리고 브라우저는 이러한 리소스를 혼합한다. 브라우저에 의해 실행된 스크립트는 이후 단계에서 더 많은 리소스를 가져올 수 있고, 그에 따라 웹 페이지를 갱신한다. 웹 페이지는 HTML 문서로 사용자가 사용자 에이전트를 제어하고 웹을 돌아다닐 수 있도록 새로운 웹 페이지를 가져오기 위해 실행되는 링크를 의미한다. 브라우저는 HTTP 요청 후 응답을 해석하여 사용자에게 표시한다.

웹 서버는 클라이언트 요청에 대해 문서를 제공하는 서버이다. 서버는 논리적으로는 단일 기계이지만, 로드 밸런싱 혹은 매번 다른 컴퓨터들의 정보를 얻고 완전하게 혹은 부분적으로 문서를 생성하는 소프트웨어의 복잡한 부분을 공유하는 서버들의 집합일 수 있다. 그리고 반드시 단일 기계일 필요는 없고, 여러 개의 서버를 동일한 머신 위에서 호스팅할 수 있다. 

웹 브라우저와 서버는 많은 HTTP 메시지를 주고 받는다. 여러 계층으로 이루어진 웹 스택 구조에서 애플리케이션 계층에서 동작하는 것을 일반적으로 프록시라고 부른다. 프록시는 캐싱, 필터링, 로드 밸런싱, 인증, 로깅 등의 기능을 제공한다.

HTTP의 특징
* HTTP는 메시지를 사람이 읽고 이해할 수 있어, 테스트하기 쉬워 간단하다.
* HTTP 헤더를 통해 HTTP를 쉽게 확장할 수 있다.
* HTTP는 상태를 저장하지 않지만, HTTP 쿠키는 상태가 있는 세션을 만들도록 해준다.
* 연결은 전송 계층에서 제어하지만, 최소한으로 신뢰할 수 있거나 메시지 손실이 없는 연결을 요구한다. 따라서 UDP가 아닌 신뢰할 수 있는 TCP를 표준으로 한다. 

HTTP로 제어할 수 있는 것
* HTTP로 문서가 캐시되는 방식을 제어할 수 있다.
* 스누핑과 다른 프라이버시 침해를 막기 위해, 브라우저는 웹 사이트 간의 엄격한 분리를 강제한다. 따라서 동일한 origin으로부터 온 페이지만이 웹 페이지의 전체 정보에 접근할 수 있는 제약사항이 있다.
* 특정 사용자만이 접근 가능한 페이지를 만들어 사용자를 인증할 수 있다. 인증은 HTTP의 헤더를 이용하거나, HTTP 쿠키를 사용해 특정 세션을 설정하는 방법 등이 있다.
* 프록시와 터널링을 제공한다. 서버 혹은 클라이언트는 종종 인트라넷에 위치하여 다른 개체들에게 그들의 실제 주소를 숨기기도 한다. HTTP 요청은 네트워크 장벽을 가로지르기 위해 프록시를 통해 나가게 된다.
* 쿠키 사용은 서버 상태를 요청과 연결하도록 해준다. 이것은 HTTP가 기본적으로 상태없는 프로토콜임에도 세션을 만들어주는 계기가 된다.

HTTP 흐름
1. TCP 연결을 연다.
2. HTTP 메소드를 전송한다.
3. 서버에 의해 전송된 응답을 읽어들인다.
4. 연결을 닫거나 다른 요청을 위해 재사용한다.

HTTP 메시지 구성 요소
요청
* 클라이언트가 수행하고자 하는 동작을 정의한 HTTP 메소드
* 가져오려는 리소스의 경로
* HTTP 프로토콜의 버전
* 서버에 추가 정보를 전달하기 위한 선택적인 헤더
응답
* HTTP 프로토콜의 버전
* 요청의 성공 여부와 그 이유를 나타내는 상태 코드
* 상태 코드의 짧은 설명을 나타내는 메시지
* HTTP 헤더

HTTP 상태 코드
1. 1xx : 정보
2. 2xx : 성공
3. 3xx : 리다이렉션
4. 4xx : 클라이언트 오류
5. 5xx : 서버 오류

---
## Browsers and how they work?
https://d2.naver.com/helloworld/59361

브라우저의 주요 기능은 사용자가 요청한 기능을 서버에 요청하고 브라우저에 표시하는 것이다. 자원은 보통 HTML 문서를 말하며, 자원의 주소는 URL에 의해 정해진다. 브라우저는 사용자 인터페이스, 브라우저 엔진, 렌더링 엔진, 통신, UI 백엔드, 자바스크립트 해석기, 자료 저장소로 이루어진다.

렌더링 엔진은 요청 받은 내용을 화면에 표시하는 일을 한다. 렌더링 엔진의 동작 과정은 아래와 같다.
1. DOM 트리 구축 위한 HTML 파싱
2. 렌더 트리 구축
3. 렌더 트리 배치
4. 렌더 트리 그리기

문서 파싱은 브라우저가 코드를 이해할 수 있는 형태로 변환하는 것을 의미한다. HTML 파서는 HTML 마크업을 파싱 트리로 변환한다. HTML은 파싱하기 어렵고 전통적인 구문 분석이 불가능하기 때문에 문맥 자유 문법이 아니다. 이는 HTML이 인기가 있는 이유이지만, XML 파서로 파싱하기 쉽지 않은 이유이기도 하다. 

HTML의 정의는 DTD 형식 안에 있다. DTD는 GML을 비롯한 HTML, XML과 같은 마크업 언어에서 문서 형식을 정의하는 것이며, `<!DOCTYPE html>`이 그것이다. 파싱 트리는 DOM 요소와 속성 노드의 트리로서 출력 트리가 된다. DOM은 문서 객체 모델의 준말로 HTML 문서의 객체 표현이고, 외부를 향하는 자바스크립트와 같은 HTML 요소의 연결 지점이다. HTML은 일반적인 파싱 기술을 사용할 수 없기 때문에 별도의 파서가 필요하다. 이는 토큰화 알고리즘과 트리구축 알고리즘으로 구성되어 있다. 반면 CSS는 문맥 자유 문법으로 전통적인 파서 유형을 이용하여 파싱이 가능하다.

웹은 파싱과 실행이 동시에 수행되는 동기화 모델이다. 파서가 `<script>` 태그를 만나면 즉시 파싱하고 실행되며, 그 동안 문서의 파싱이 중단된다. 스크립트가 외부에 있는 경우 네트워크로부터 자원을 가져오는 동안 파싱이 중단된다. 이를 `defer`로 명시할 수 있으며, 혹은 HTML5의 경우 비동기 처리를 하는 속성을 명시하여 별도의 맥락에 의해 파싱할 수도 있다. 한편 스타일시트는 이론적으로 DOM 트리를 변경하지 않기 때문에 파싱을 기다릴 필요가 없지만, 스크립트가 문서를 파싱하는 동안 스타일 정보를 요청하면 문제가 발생한다. 그래서 렌더링 엔진에서는 스타일시트 파싱 먼저 진행하거나, 문제가 될 속성이 발견되는 경우에만 스크립트를 중단하는 것으로 처리한다.

DOM 트리가 구축되는 동안 브라우저는 렌더 트리를 구축한다. 표시해야 할 순서와 문서의 시각적인 구성 요소로써 올바른 순서로 내용을 그려내는 것이 목적이다. 렌더 트리와 DOM 트리는 서로 부합하지만 일대일 대응은 아니다. 예를 들어 `<head>`와 같은 비시각적 요소는 렌더 트리에 추가되지 않는다. 또, 렌더 트리를 구축하기 위해서는 객체의 시각적 속성에 대해 각 요소의 스타일 속성을 계산해야 한다. 이는 꽤 복잡하기 때문에, 렌더링 엔진에서 상세한 규칙을 정해놓고 있다. 스타일을 정의하는 방법은 CSS 규칙을 외부 스타일 시트나 style 요소에서 선언, 인라인 스타일 속성, HTML의 시각적 속성을 이용하는 방법 등 다양하며 cascading, 즉 우선 순위가 존재한다. 

렌더러가 생성되어 트리에 추가될 때 크기와 위치 정보는 없는데 이런 값을 계산하는 것을 배치 또는 리플로라고 부른다. 소소한 변경 때문에 전체 배치를 변경하지 않도록 브라우저는 더티 비트 체제를 사용한다. 

HTML 문서에 그림을 그리기 위해 캔버스 요소를 사용한다. 그리고 자주 사용되는 그림으로 박스 모델이 있다. 박스 모델은 display 속성이 있는데 아래와 같은 유형을 갖는다.
* bolck : 블록 상자를 만든다.
* inline : 하나 또는 그 이상의 인라인 상자를 만든다. 인라인 상자는 블록이 되지 않고, 블록 내부에 포함된다.
* none : 박스를 만들지 않는다.
블록은 다른 블록 아래 수직으로 배치되고, 인라인은 수평으로 배치가 된다.

위치를 잡는 방법도 여러가지 있다.
* 상대적인 위치 : 일반적인 흐름에 따라 위치를 결정한 다음 필요한 만큼 이동한다.
* 플로트 : 라인의 왼쪽 또는 오른쪽으로 이동한다. 박스가 이 주변을 흐르도록 배치된다.
* 절대적인(absolute)와 고정된(fixed) 위치 : 절대와 고정 배치는 일반적인 흐름과 무관하게 결정되고, 일반적인 흐름에 관여하지 않으며, 면적은 부모에 따라 상대적이다. 고정인 경우 뷰포트로부터 위치를 결정한다.

마지막으로 3차원을 표현하기 위해서는 z-index 속성을 이용해 표현한다.

---
## DNS and how it wokrs?
https://aws.amazon.com/ko/route53/what-is-dns/

DNS란 사람이 읽을 수 있는 도메인 이름을 머신이 읽을 수 있는 IP 주소로 변환하는 것 혹은 그 반대의 변환을 수행하는 시스템이다. DNS 서버는 쿼리 요청을 통해 도메인 이름을 IP 주소로 변환하여 사용자를 어떤 서버에 연결할 것인지를 제어한다.

DNS 서비스 유형은 다음과 같다.
* 신뢰할 수 있는 DNS : 개발자가 퍼블릭 DNS 이름을 관리하는 데 사용하는 업데이트 메커니즘을 제공한다. 이 메커니즘을 통해 DNS 쿼리에 응답하고 도메인 이름을 IP 주소로 변환하여 컴퓨터를 통신하게 만든다. 신뢰할 수 있는 DNS는 도메인에 대해 최종 권한이 있어 재귀적 DNS 서버에 IP 주소 정보가 담긴 답을 제공할 책임이 있다.
* 재귀적 DNS : 클라이언트를 대신해서 DNS 정보를 가져올 수 있는 중간자 역할을 한다. 일정 기간 캐시된 또는 저장된 DNS 참조를 가지고 있는 경우, 소스 또는 IP 정보를 제공하여 DNS 쿼리에 답을 한다. 그렇지 않다면, 해당 정보를 찾기 위해 쿼리를 DNS 서버에 전달한다.

웹 애플리케이션이 라우팅하는 흐름은 다음과 같다.
클라이언트가 도메인 입력 👉 DNS 해석기(재귀적 DNS) 👉 [DNS 루트 이름 서버 👉 TLD 이름 서버 👉 신뢰할 수 있는 DNS(권한 있는 DNS 서버)] 👉 웹 브라우저 👉 IP 주소로 전송 요청

---
## What is domain name?
https://developer.mozilla.org/ko/docs/Learn/Common_questions/What_is_a_domain_name

인터넷이 연결된 컴퓨터는 IP 주소를 통해 연결된다. 도메인 이름은 인터넷 인프라의 핵심으로 인터넷에서 사용할 수 있는 모든 웹 서버에 대해 사람이 읽을 수 있는 주소를 제공한다. 

도메인 네임은 "."으로 구분한다. 도메인 네임의 제일 오른쪽에 있는 것(.com, .org, .net 등)을 최상위 도메인(TLD)라고 한다. 그 왼쪽에 있는 것은 도메인으로 개수나 크기의 제한은 없다.

도메인은 구입하여 소유하는 것이 아니라, 특정 기간 만큼 사용 권리에 대한 비용을 지불하는 것이다. 그리고 더 사용하려면 갱신을 하는 형태이다.

사용하고 싶은 도메인 네임이 사용할 수 있는지 확인 후 사용을 신청해야 한다. 등록된 도메인 네임은 DNS 서버의 데이터베이스에 저장되는데, 데이터베이스의 정보를 새로 고치기 위한 시간이 소요된다.

---
## What is hosting?
https://www.one.com/en/hosting/what-is-web-hosting

웹 호스팅은 웹사이트 파일을 인터넷에 게시하는 껏을 말한다. 일반적으로 웹사이트를 호스팅하기 위해서는 서비스와 기술을 임대해야 한다. 웹 호스트는 서버가 작동하고 실행 중인지 확인할 책임이 있으며, 보안 침해 방지 및 파일, 자산, 데이터베이스를 저장해주어야 한다.

호스팅의 종류는 아래와 같다.
- 공유 호스팅: 웹 호스팅 공급자가 동일한 서버에서 여러 다른 웹사이트를 호스팅하는 것을 말한다. 동일한 서버를 공유하므로 저렴하다는 장점이 있다. 과거에는 서버를 공유하면 단일 사이트에서 트래픽이나 리소스가 급증하면 이웃 웹사이트의 속도도 느려질 수 있었지만, 요즘은 이러한 성능을 보장하는 리소스가 제공되고 있다.
- 워드프레스 호스팅: 서버 수준에서 워드프레스에 최적화된 호스팅을 의미한다.
- VPS 호스팅: VPS는 가상 사설 서버를 의미한다. 공유 호스팅과 마찬가지로 서로 다른 웹사이트와 물리적 서버를 공유하지만, 각 VPS 테넌트에 전용 리소스가 보장되는 자체 파티션이 있다. 따라서 지원 수준에 따라 가격이 다르며, VPS 호스팅은 서버 관리 기술 경험이 많은 사용자에게 권장된다.
- 전용 호스팅: 전체 서버를 소유하고 있는 것이다. VPS처럼 액세스 할 수 있지만 다른 사이트나 앱과 서버를 공유할 필요가 없다.
- 클라우드 호스팅: 처음에는 여러 서버로 확장 가능한 VPS 설정을 나타내는 용어로 쓰였다. 이럴 경우 갑자기 트래픽이 급증하더라도 더 많은 리소스를 프로비저닝하고 원활하게 실행할 수 있다. 하지만 최근에는 일반 공유 또는 VPS 호스팅이라는 용어를 함께 사용하여, 클라우드 컴퓨팅 서비스가 포함된 클라우드 호스팅을 제공한다.

무료 호스팅도 가능하지만 유료 호스팅과 비교하여 대역폭 및 디스크 공간, 콘텐츠 제한, 보안 위반, 도메인 이름 및 URL, 서버 속도에 대해 단점이 존재한다.

AWS, Azure, Google Cloud 등 어떤 VPS 서비스를 이용할지 가성비를 잘 따져서 선택해야 한다. ([VPSBenchmarks](https://www.vpsbenchmarks.com/)) VPS뿐 아니라 데이터베이스를 관리하기 위한 시스템 등 모든 서비스가 마찬가지이다.

여러 유용한 서비스가 있으니, 개발 시 이용할 것이 있을지 잘 찾아본다.
- Netfify: 정적 웹 사이트를 위한 호스팅 및 서버리스 백엔드 서비스를 제공한다.
- imgix: 이미지 최적화 서비스를 제공한다.
- Cloudinary: imgix와 마찬가지로 비디오, 이미지를 관리하기 위한 서비스이다. 가격 측정 방식이 imgix보다 덜 투명하기 때문에 구현하고자 하는 서비스에 적절할지 잘 고려해야 한다.
